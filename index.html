<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>WePlay Simulator v2</title>
<style>
body{
    font-family:Arial;
    background:#f4f6fb;
    padding:20px;
}

h1{margin-top:0}

.card{
    background:white;
    padding:15px;
    border-radius:10px;
    box-shadow:0 4px 10px rgba(0,0,0,0.1);
    margin-bottom:15px;
}

.simGrid{
    display:grid;
    grid-template-columns: 380px 1fr;
    gap:20px;
}

button{
    border:none;
    padding:8px 12px;
    border-radius:6px;
    cursor:pointer;
    font-weight:bold;
}

.btnTime{background:#4CAF50;color:white}
.btnUndo{background:#f44336;color:white}

.actionGrid{
    display:grid;
    grid-template-columns: repeat(4,1fr);
    gap:10px;
}

.actionBtn{
    background:#eef2ff;
    font-size:22px;
    padding:15px;
}

table{
    width:100%;
    border-collapse:collapse;
}

td,th{
    border-bottom:1px solid #ddd;
    padding:6px;
    text-align:center;
}

.timeline{
    max-height:500px;
    overflow-y:auto;
}

</style>
</head>
<body>

<h1>STEP 1 ‚Äî GAME CONFIG</h1>

<h3>Nh·∫≠p s·ªë level mu·ªën d√πng</h3>
Tree levels <input id="treeLvCount" value="5">
Pump levels <input id="pumpLvCount" value="5">
House levels <input id="houseLvCount" value="5">
Door levels <input id="doorLvCount" value="5">

<button onclick="generateTables()">T·∫°o b·∫£ng nh·∫≠p li·ªáu</button>
<button onclick="saveConfig()">üíæ L∆∞u config</button>
<button onclick="loadConfig()">üìÇ T·∫£i config</button>
<div id="tables"></div>

<button onclick="startSim()">üöÄ B·∫ÆT ƒê·∫¶U GI·∫¢ L·∫¨P</button>

<hr>
<div id="simulator" class="hidden">

<h1>STEP 2 ‚Äî SIMULATOR</h1>

<div class="simGrid">

<div>

<div class="card">
<h3>Time Control</h3>
<button class="btnTime" onclick="nextSecond()">+1 Second</button>
<button class="btnUndo" onclick="prevSecond()">Undo</button>
</div>

<div class="card">
<h3>Manual Adjust</h3>
Gold <input id="minusGold" value="50">
<button onclick="removeGold()">üí∞-</button>
<br><br>
Water <input id="minusWater" value="50">
<button onclick="removeWater()">üíß-</button>
</div>

<div class="card">
<h3>Actions</h3>
<div class="actionGrid">
<button class="actionBtn" onclick="buyTree()">üå≥</button>
<button class="actionBtn" onclick="buyPump()">üíß</button>
<button class="actionBtn" onclick="upgradeTree()">üå≤‚¨Ü</button>
<button class="actionBtn" onclick="upgradePump()">üí¶‚¨Ü</button>
<button class="actionBtn" onclick="upgradeHouse()">üè†‚¨Ü</button>
<button class="actionBtn" onclick="upgradeDoor()">üö™‚¨Ü</button>
</div>

</div>

</div>

<div class="card timeline">
<table id="timeline">
<tr>
<th>Time</th>
<th>Gold</th>
<th>Water</th>
<th>Trees</th>
<th>Pumps</th>
<th>House</th>
<th>Door</th>
</tr>
</table>
</div>

</div>
</div>

<script>

let CONFIG = {};
let history=[];
let state;

// ===== INPUT TABLE FUNCTIONS (b·ªã thi·∫øu) =====
function makeLevelTable(name,count){
    let html=`<h3>${name}</h3>
    <table>
    <tr>
        <th>Lv</th>
        <th>Gold cost</th>
        <th>Water cost</th>
        <th>Production/s</th>
        <th>Req Door Lv</th>
    </tr>`;

    for(let i=1;i<=count;i++){
        html+=`<tr>
        <td>${i}</td>
        <td><input id="${name}_gold_${i}" value="0"></td>
        <td><input id="${name}_water_${i}" value="0"></td>
        <td><input id="${name}_prod_${i}" value="0"></td>
        <td><input id="${name}_doorReq_${i}" value="1"></td>
        </tr>`;
    }

    html+="</table>";
    return html;
}

function generateTables(){
    tables.innerHTML =
        makeLevelTable("tree",+treeLvCount.value)+
        makeLevelTable("pump",+pumpLvCount.value)+
        makeLevelTable("house",+houseLvCount.value)+
        makeLevelTable("door",+doorLvCount.value);
}

function readTable(name,count){
    let arr=[];
    for(let i=1;i<=count;i++){
        arr.push({
    gold:+document.getElementById(`${name}_gold_${i}`).value,
    water:+document.getElementById(`${name}_water_${i}`).value,
    prod:+document.getElementById(`${name}_prod_${i}`).value,
    doorReq:+document.getElementById(`${name}_doorReq_${i}`).value
});
    }
    return arr;
}

function saveConfig(){
    let configData = {
        treeLvCount: +treeLvCount.value,
        pumpLvCount: +pumpLvCount.value,
        houseLvCount: +houseLvCount.value,
        doorLvCount: +doorLvCount.value,
        tables: {}
    };

    function readTableValues(name,count){
        let arr=[];
        for(let i=1;i<=count;i++){
            arr.push({
                gold: document.getElementById(`${name}_gold_${i}`).value,
                water: document.getElementById(`${name}_water_${i}`).value,
                prod: document.getElementById(`${name}_prod_${i}`).value,
                doorReq: document.getElementById(`${name}_doorReq_${i}`).value
            });
        }
        return arr;
    }

    configData.tables.tree  = readTableValues("tree",  configData.treeLvCount);
    configData.tables.pump  = readTableValues("pump",  configData.pumpLvCount);
    configData.tables.house = readTableValues("house", configData.houseLvCount);
    configData.tables.door  = readTableValues("door",  configData.doorLvCount);

    localStorage.setItem("weplayConfig", JSON.stringify(configData));
    alert("ƒê√£ l∆∞u config!");
}


function loadConfig(){
    let data = localStorage.getItem("weplayConfig");
    if(!data){
        alert("Ch∆∞a c√≥ config ƒë∆∞·ª£c l∆∞u!");
        return;
    }

    data = JSON.parse(data);

    treeLvCount.value  = data.treeLvCount;
    pumpLvCount.value  = data.pumpLvCount;
    houseLvCount.value = data.houseLvCount;
    doorLvCount.value  = data.doorLvCount;

    // t·∫°o l·∫°i b·∫£ng
    generateTables();

    function fillTable(name,arr){
        arr.forEach((row,i)=>{
            let idx=i+1;
            document.getElementById(`${name}_gold_${idx}`).value    = row.gold;
            document.getElementById(`${name}_water_${idx}`).value   = row.water;
            document.getElementById(`${name}_prod_${idx}`).value    = row.prod;
            document.getElementById(`${name}_doorReq_${idx}`).value = row.doorReq;
        });
    }

    fillTable("tree",  data.tables.tree);
    fillTable("pump",  data.tables.pump);
    fillTable("house", data.tables.house);
    fillTable("door",  data.tables.door);

    alert("ƒê√£ t·∫£i config!");
}


// ===== FORMAT TIME =====
function formatTime(sec){
    let m=Math.floor(sec/60).toString().padStart(2,"0");
    let s=(sec%60).toString().padStart(2,"0");
    return `${m}:${s}`;
}

function startSim(){
    CONFIG.tree=readTable("tree",+treeLvCount.value);
    CONFIG.pump=readTable("pump",+pumpLvCount.value);
    CONFIG.house=readTable("house",+houseLvCount.value);
    CONFIG.door=readTable("door",+doorLvCount.value);

    state={
    time:8,
    gold:0,
    water:0,
    houseLv:1,
    doorLv:1,
    trees:[],   // ‚≠ê danh s√°ch t·ª´ng c√¢y
    pumps:[]    // ‚≠ê danh s√°ch t·ª´ng th√πng n∆∞·ªõc
};



    history=[JSON.parse(JSON.stringify(state))];
    simulator.classList.remove("hidden");
    render();
}

// ===== PRODUCTION =====
function produceResources(){
    let goldGain=0;
    let waterGain=0;

    // m·ªói c√¢y t·∫°o v√†ng theo level ri√™ng
    state.trees.forEach(lv=>{
        goldGain += CONFIG.tree[lv-1].prod;
    });

    // nh√† t·∫°o v√†ng
    goldGain += CONFIG.house[state.houseLv-1].prod;

    // m·ªói pump t·∫°o n∆∞·ªõc theo level ri√™ng
    state.pumps.forEach(lv=>{
        waterGain += CONFIG.pump[lv-1].prod;
    });

    state.gold += goldGain;
    state.water += waterGain;
}

// ===== TIME CONTROL =====
function nextSecond(){
    produceResources();
    state.time++;
    history.push(JSON.parse(JSON.stringify(state)));
    render();
}

function prevSecond(){
    if(history.length<=1) return;
    history.pop();
    state=JSON.parse(JSON.stringify(history[history.length-1]));
    timeline.deleteRow(-1);
}

// ===== ACTIONS =====
function buyTree(){
    let cfg = CONFIG.tree[0]; // mua c√¢y lv1
    if(state.gold>=cfg.gold && state.water>=cfg.water){
        state.gold -= cfg.gold;
        state.water -= cfg.water;
        state.trees.push(1); // th√™m 1 c√¢y lv1
        renderInstant();
    }
}


function buyPump(){
    let cfg = CONFIG.pump[0];
    if(state.gold>=cfg.gold && state.water>=cfg.water){
        state.gold -= cfg.gold;
        state.water -= cfg.water;
        state.pumps.push(1);
        renderInstant();
    }
}


function upgradeHouse(){
    let lvl=state.houseLv;
    if(lvl>=CONFIG.house.length) return;
    let cfg=CONFIG.house[lvl];

    if(state.doorLv < cfg.doorReq) return;

    if(state.gold>=cfg.gold && state.water>=cfg.water){
        state.gold-=cfg.gold;
        state.water-=cfg.water;
        state.houseLv++;
        renderInstant();
    }
}


function upgradeDoor(){
    let lvl=state.doorLv;
    if(lvl>=CONFIG.door.length) return;
    let cfg=CONFIG.door[lvl];
    if(state.gold>=cfg.gold && state.water>=cfg.water){
        state.gold-=cfg.gold;
        state.water-=cfg.water;
        state.doorLv++;
        renderInstant();
    }
}

function upgradeTree(){
    if(state.trees.length==0){
        alert("Ch∆∞a c√≥ c√¢y!");
        return;
    }

    // ch·ªçn c√¢y level th·∫•p nh·∫•t ƒë·ªÉ n√¢ng
    let index = state.trees.indexOf(Math.min(...state.trees));
    let currentLv = state.trees[index];

    if(currentLv >= CONFIG.tree.length) return;

    let cfg = CONFIG.tree[currentLv];

    if(state.doorLv < cfg.doorReq){
        alert("C·∫ßn Door Lv " + cfg.doorReq);
        return;
    }

    if(state.gold>=cfg.gold && state.water>=cfg.water){
        state.gold -= cfg.gold;
        state.water -= cfg.water;
        state.trees[index]++; // ‚≠ê ch·ªâ n√¢ng 1 c√¢y
        renderInstant();
    }
}


function upgradePump(){
    if(state.pumps.length==0){
        alert("Ch∆∞a c√≥ pump!");
        return;
    }

    let index = state.pumps.indexOf(Math.min(...state.pumps));
    let currentLv = state.pumps[index];

    if(currentLv >= CONFIG.pump.length) return;

    let cfg = CONFIG.pump[currentLv];

    if(state.doorLv < cfg.doorReq){
        alert("C·∫ßn Door Lv " + cfg.doorReq);
        return;
    }

    if(state.gold>=cfg.gold && state.water>=cfg.water){
        state.gold -= cfg.gold;
        state.water -= cfg.water;
        state.pumps[index]++;
        renderInstant();
    }
}

// ===== RENDER =====
function renderInstant(){
    timeline.deleteRow(-1);
    render();
}

function render(){
    let r = timeline.insertRow(-1);

    // ===== ƒê·∫æM S·ªê C√ÇY THEO LEVEL =====
    let treeCountByLevel = new Array(CONFIG.tree.length).fill(0);
    state.trees.forEach(lv => treeCountByLevel[lv-1]++);

    let pumpCountByLevel = new Array(CONFIG.pump.length).fill(0);
    state.pumps.forEach(lv => pumpCountByLevel[lv-1]++);

    // convert th√†nh text
    let treeText = treeCountByLevel
        .map((count,i)=>`L${i+1}:${count}`)
        .join(" | ");

    let pumpText = pumpCountByLevel
        .map((count,i)=>`L${i+1}:${count}`)
        .join(" | ");

    r.innerHTML = `
    <td>${formatTime(state.time)}</td>
    <td>${state.gold.toFixed(1)}</td>
    <td>${state.water.toFixed(1)}</td>
    <td>${treeText}</td>
    <td>${pumpText}</td>
    <td>${state.houseLv}</td>
    <td>${state.doorLv}</td>`;
}



</script>






